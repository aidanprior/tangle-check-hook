#!/usr/bin/env bash
set -euo pipefail

# Configuration defaults
SYNC_GITATTRIBUTES=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --sync-gitattributes)
      SYNC_GITATTRIBUTES=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

root="$(git rev-parse --show-toplevel)"
cd "$root"
ORG_FILE="README.org"

# --- collect tangle targets from README.org without writing files ---
# --- collect tangle targets from README.org without writing files ---
declare -a TARGETS=()
tmpfile="$(mktemp -t tangle_targets.XXXXXX)"
# Generate absolute target paths (one per line)
emacs -Q --batch \
  --eval "(setq org-id-locations-file nil
                 org-id-locations nil
                 org-id-extra-files nil)" \
  -l org -l ob-tangle \
  --eval "(with-current-buffer (find-file-noselect \"${root}/${ORG_FILE}\")
             (let* ((alist (org-babel-tangle-collect-blocks))
                    (files (delete-dups (mapcar #'car alist))))
               (princ (mapconcat (lambda (f) (expand-file-name f \"${root}\"))
                                 files
                                 \"\n\"))))" > "$tmpfile"

# Read back into TARGETS without spawning a subshell
while IFS= read -r line; do
  [ "$line" != "" ] && TARGETS+=("$line")
done < "$tmpfile"
rm -f "$tmpfile"
# Helper: staged? (test a pathspec list)
staged_any() {
  # no args → false
  [ "$#" -eq 0 ] && return 1
  git diff --cached --quiet -- "$@" && return 1 || return 0
}

# Helper: run tangling + stage
tangle_and_stage() {
  emacs -Q --batch \
  --eval "(setq org-id-locations-file nil)" \
  -l org \
    --eval "(setq org-confirm-babel-evaluate nil
                  org-src-preserve-indentation t)" \
    --eval "(org-babel-tangle-file \"${root}/${ORG_FILE}\")" >/dev/null
  git add -A
}

# Helper: sync .gitattributes with generated files
sync_gitattributes() {
  local gitattributes_file="${root}/.gitattributes"
  local temp_file="${gitattributes_file}.tmp"
  
  # Create temp file for new .gitattributes content
  : > "$temp_file"
  
  # Copy existing lines that are not generated file entries and not managed by tangle-check
  if [ -f "$gitattributes_file" ]; then
    while IFS= read -r line; do
      # Skip lines that contain 'linguist-generated=true' unless they have a tangle-check comment marker
      if [[ "$line" =~ linguist-generated=true ]] && [[ ! "$line" =~ "#".*"tangle-check:".*"keep" ]]; then
        continue
      fi
      echo "$line" >> "$temp_file"
    done < "$gitattributes_file"
  fi
  
  # Add header comment if temp file doesn't have our marker
  if ! grep -q "# Generated by tangle-check-hook" "$temp_file" 2>/dev/null; then
    echo "" >> "$temp_file"
    echo "# Generated by tangle-check-hook - tangled files marked as generated" >> "$temp_file"
  fi
  
  # Add all tangle targets as generated files
  if ((${#rel_targets[@]})); then
    for target in "${rel_targets[@]}"; do
      echo "$target linguist-generated=true" >> "$temp_file"
    done
  fi
  
  # Only update if content changed
  if ! cmp -s "$temp_file" "$gitattributes_file" 2>/dev/null; then
    mv "$temp_file" "$gitattributes_file"
    echo "✓ Updated .gitattributes with ${#rel_targets[@]} generated file(s)"
    git add "$gitattributes_file"
  else
    rm -f "$temp_file"
  fi
}

# Is README.org staged?
org_staged=false
if git diff --cached --quiet -- "$ORG_FILE"; then
  org_staged=false
else
  org_staged=true
fi

# Build an array of target paths relative to repo for git pathspec
declare -a rel_targets=()
if ((${#TARGETS[@]})); then
  for f in "${TARGETS[@]}"; do
    [ "${f-}" = "" ] && continue
    rel="${f#"${root}"/}"
    rel_targets+=("$rel")
  done
fi

# Are any target files staged?
targets_staged=false
if ((${#rel_targets[@]})) && staged_any "${rel_targets[@]}"; then
  targets_staged=true
fi

# Decision matrix
if [ "$org_staged" = false ] && [ "$targets_staged" = false ]; then
  echo "✓ Neither ${ORG_FILE} nor tangled files are staged."
  exit 0
fi

if [ "$org_staged" = false ] && [ "$targets_staged" = true ]; then
  echo "✗ Tangled files are staged but ${ORG_FILE} is not."
  echo "  Edit ${ORG_FILE} and let this hook regenerate them."
  echo "  If you must commit direct edits, force the commit:"
  echo "    git commit --no-verify"
  echo "  or skip this hook:"
  echo "    SKIP=org-tangle-smart-targets git commit"
  exit 1
fi

# README.org is staged (targets may or may not be)
tangle_and_stage

# Sync .gitattributes if enabled
if [ "$SYNC_GITATTRIBUTES" = true ]; then
  sync_gitattributes
fi

if [ "$targets_staged" = true ]; then
  # Ensure no drift remains after tangling
  if ! git diff --quiet; then
    echo "✗ After tangling, there are still unstaged changes in tangled outputs."
    echo "  That means the staged edits to targets don’t match code produced"
    echo "  from ${ORG_FILE}."
    echo
    echo "Files still differing:"
    git --no-pager diff --name-only
    echo
    echo "Hints:"
    echo "  • If you want the *tangle result* to win:"
    echo "      git add -A && git commit"
    echo "  • If you intentionally want the *staged* edits anyway:"
    echo "      git commit --no-verify"
    echo "    or  SKIP=org-tangle-smart-targets git commit"
    exit 1
  fi
fi

# Clean → success
exit 0
